(define-module (crates-io er go ergotree-interpreter) #:use-module (crates-io))

(define-public crate-ergotree-interpreter-0.7.0 (c (n "ergotree-interpreter") (v "0.7.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bs58") (r "^0.4.0") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.3.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.7.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.7.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "impl-trait-for-tuples") (r "^0.2.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num") (r "^0.3.1") (d #t) (k 0)) (d (n "num-bigint") (r "^0.3.0") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.7") (d #t) (k 0)) (d (n "sigma-ser") (r "^0.2.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "17fhjqbz0w7gkjall0zkvck4rhnpvsfxfz36wxc4l9dkzfy744jy") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.8.0 (c (n "ergotree-interpreter") (v "0.8.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.4.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.8.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.8.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.2.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0ww0ji110b9pzrkx33d58pbmb0n106274cx53d2cpp496m2zbhqf") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.9.0 (c (n "ergotree-interpreter") (v "0.9.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.5.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.9.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.9.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.2.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "04nb0c2minkvmp78f9h771wpispfbdfj1kfk0ckz34j1bm4xnbfh") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.10.0 (c (n "ergotree-interpreter") (v "0.10.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.6.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.10.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.10.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.2.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0diwxbl5jy987w0qka95s601n1kfbwj8zgskd5m54dicqy25vx3q") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.11.0 (c (n "ergotree-interpreter") (v "0.11.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.7.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.11.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.11.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1szgszb4d2fkm01ih21al0l7sr8gqgra176ww3zzhiy61k6j5kr9") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.12.0 (c (n "ergotree-interpreter") (v "0.12.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.8.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.12.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.12.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0jcd0hkz760jdd3qnpwp0jid86g8bkgwl9z18gz2mc7q6wnq0fkl") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.13.0 (c (n "ergotree-interpreter") (v "0.13.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.9.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.13.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.13.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "149kkqakky8jnwhmq1qppjzzrmr4x968d8la3xvnap33z0lfxy74") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.13.1 (c (n "ergotree-interpreter") (v "0.13.1") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.5.0") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.9.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.13.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.13.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.4.2") (f (quote ("rand" "zeroize"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "19cdgcvg45ginpvladc28rhzsyp87a1qy0glgi6qrfw6wjrd2264") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.13.2 (c (n "ergotree-interpreter") (v "0.13.2") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.9.6") (f (quote ("zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.9.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.13.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.13.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.7.2") (f (quote ("zeroize" "arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.7") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0ja0l51mzyyshvhcjcrdw768jjlb0scpa91mqrzadsgbzs8cc7gz") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.13.3 (c (n "ergotree-interpreter") (v "0.13.3") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.9.6") (f (quote ("zeroize"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.9.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.13.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.13.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.7.2") (f (quote ("zeroize" "arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (o #t) (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.7") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.2.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.2.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "17pkgpsva92yg8f663xfk8xs49pqgs47r70pl19wxfzrmh4qgnm4") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.14.0 (c (n "ergotree-interpreter") (v "0.14.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.10.6") (f (quote ("zeroize" "ff"))) (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.10.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.14.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.14.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.9.6") (f (quote ("zeroize" "arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.3.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "192smn5b2v04b2v2iziq3f2dj9hjms5krsqllbwb2kqisfb25yjx") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.15.0 (c (n "ergotree-interpreter") (v "0.15.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.5.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.2.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.11.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.15.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.15.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.15.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "sigma-ser") (r "^0.4.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.4.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0nffhc9kij4hsdvc4djv0l3irgvqkdn5ij3992vg4mh3vyh4pyb0") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive"))))))

(define-public crate-ergotree-interpreter-0.16.0 (c (n "ergotree-interpreter") (v "0.16.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.6.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.3.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.12.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.16.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.16.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.16.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "sigma-ser") (r "^0.5.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.5.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0nqv0s7i6xl16894lpyzbkqsi0wv8jdmv6wzjv5hb4spz2dxdmhl") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.16.1 (c (n "ergotree-interpreter") (v "0.16.1") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.6.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.3.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.12.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.16.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.16.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.16.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "sigma-ser") (r "^0.5.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.5.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "10dyh99hvgs3yidc11kb6k0cyingkg6jxj6v54bifrvypj8v3hl1") (f (quote (("default") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.17.0 (c (n "ergotree-interpreter") (v "0.17.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.6.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.4.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.13.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.17.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.17.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.17.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.6.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.5.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0sngrld9lvhlgnm8kp7kqfzjs7pcb7yn8ws1djxd1llxqswr6rbs") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.18.0 (c (n "ergotree-interpreter") (v "0.18.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.6.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.5.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.14.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.18.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.18.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.18.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.7.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.6.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0sybf01mga73nbf2ycjw2jzp4z94yhjsvass3mz1rq734i59j5l9") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.19.0 (c (n "ergotree-interpreter") (v "0.19.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.6.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.15.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.19.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.19.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.19.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.4") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.8.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.7.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1rhij44xqr7y8niv3g1i65gcz8ji6vz6rl2hrfbb1b68p7al62fm") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.20.0 (c (n "ergotree-interpreter") (v "0.20.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.7.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.16.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.20.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.20.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.20.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.9.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.8.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1z2kybf5mf76hamyb5j9krqs1ld4ydbn1g7jyi434zc212hai5fk") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.21.0 (c (n "ergotree-interpreter") (v "0.21.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.9") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.11.6") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.8.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.17.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.21.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.21.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.21.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.10.0") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0.0") (d #t) (k 2)) (d (n "proptest-derive") (r "^0.3.0") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.10.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.9.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0kks9bspc5fqj4xcnh67sxwq2mgzzglkyv940a5sqnlvpzv8dz96") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.21.1 (c (n "ergotree-interpreter") (v "0.21.1") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.8.1") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.17.1") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.21.1") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.21.1") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.21.1") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.11") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.10.1") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.9.1") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0zdwz5kxsivrx8lnj9dh0fp95fs0y3mx19w4c40vawfms7kaqgml") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.22.0 (c (n "ergotree-interpreter") (v "0.22.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.9.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.18.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.22.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.22.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.22.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (d #t) (k 0)) (d (n "k256") (r "^0.11") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "^1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "^1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.11.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.10.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1mwym0i55hs7llnr9dycwc83gh8i5wvz125jal49y31ihnx12xs3") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.23.0 (c (n "ergotree-interpreter") (v "0.23.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.10.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.19.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.23.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.23.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.23.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.11") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.12.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.11.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1lrajpgl1wy7fs6khrjgjy0hxwm5c3pr5wahxp2r6v2xhchgkwi2") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.24.0 (c (n "ergotree-interpreter") (v "0.24.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.11.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.20.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.24.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.24.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.24.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.11") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.13.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.12.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1m4frr957zg0z52zz9zljig40gyc6zzchl6yrx6s0mddmi7jh6n4") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.24.1 (c (n "ergotree-interpreter") (v "0.24.1") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.11.1") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.20.1") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.24.1") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.24.1") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "gf2_192") (r "^0.24.1") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.13.1") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.13.1") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.12.1") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0zzp8pzhf8afr4h2fmbdwpq5rpigd8mzpcd6jyj3nvvnrafvzs4q") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.25.0 (c (n "ergotree-interpreter") (v "0.25.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.12.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.21.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.25.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.25.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "expect-test") (r "^1.4.1") (d #t) (k 2)) (d (n "gf2_192") (r "^0.25.0") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.13.1") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "miette") (r "^5") (f (quote ("fancy"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.14.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.13.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "1ggb4xlwcwlnsgi5c134jp2bgbcn7kfw0n47kjr6f08ayrkj9d0p") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.26.0 (c (n "ergotree-interpreter") (v "0.26.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.13.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.22.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.26.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.26.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "expect-test") (r "^1.4.1") (d #t) (k 2)) (d (n "gf2_192") (r "^0.26.0") (d #t) (k 0)) (d (n "hashbrown") (r "^0.14.1") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.13.1") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "miette") (r "^5") (f (quote ("fancy"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "scorex_crypto_avltree") (r "^0.1.0") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.15.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.14.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "111jpa0h6fr898w3ajbg9n6wnsbingk7y0bqbyr8cfynnxzc2czs") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.27.0 (c (n "ergotree-interpreter") (v "0.27.0") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.14.0") (d #t) (k 0)) (d (n "ergo_avltree_rust") (r "^0.1.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.23.0") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.27.0") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.27.0") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "expect-test") (r "^1.4.1") (d #t) (k 2)) (d (n "gf2_192") (r "^0.27.0") (d #t) (k 0)) (d (n "hashbrown") (r "^0.14.1") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.13.1") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "miette") (r "^5") (f (quote ("fancy"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.15.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.14.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "06ycprm789j47cjla48dwqf43rh6ps9mrhv2ddsacvcqkmvpvrll") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

(define-public crate-ergotree-interpreter-0.27.1 (c (n "ergotree-interpreter") (v "0.27.1") (d (list (d (n "base16") (r "^0.2.1") (d #t) (k 0)) (d (n "blake2") (r "^0.10") (d #t) (k 0)) (d (n "bounded-vec") (r "^0.7.0") (f (quote ("serde"))) (d #t) (k 0)) (d (n "bytes") (r "^1.1") (d #t) (k 0)) (d (n "derive_more") (r "^0.99") (d #t) (k 0)) (d (n "elliptic-curve") (r "^0.12") (f (quote ("ff"))) (d #t) (k 0)) (d (n "ergo-chain-types") (r "^0.14.1") (d #t) (k 0)) (d (n "ergo_avltree_rust") (r "^0.1.0") (d #t) (k 0)) (d (n "ergoscript-compiler") (r "^0.23.1") (d #t) (k 2)) (d (n "ergotree-ir") (r "^0.27.1") (d #t) (k 0)) (d (n "ergotree-ir") (r "^0.27.1") (f (quote ("arbitrary"))) (d #t) (k 2)) (d (n "expect-test") (r "^1.4.1") (d #t) (k 2)) (d (n "gf2_192") (r "^0.27.1") (d #t) (k 0)) (d (n "hashbrown") (r "^0.14.1") (d #t) (k 0)) (d (n "indexmap") (r "^1.3.2") (f (quote ("serde"))) (d #t) (k 0)) (d (n "k256") (r "^0.13.1") (f (quote ("arithmetic" "ecdsa"))) (d #t) (k 0)) (d (n "lazy_static") (r "^1.4") (d #t) (k 0)) (d (n "miette") (r "^5") (f (quote ("fancy"))) (d #t) (k 0)) (d (n "num-bigint") (r "^0.4.0") (d #t) (k 0)) (d (n "num-traits") (r "^0.2.14") (d #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (o #t) (k 0)) (d (n "proptest") (r "=1.0") (f (quote ("std"))) (k 2)) (d (n "proptest-derive") (r "^0.3") (o #t) (d #t) (k 0)) (d (n "rand") (r "^0.8.5") (d #t) (k 0)) (d (n "serde") (r "^1.0") (f (quote ("derive"))) (o #t) (d #t) (k 0)) (d (n "serde_json") (r "^1.0") (f (quote ("arbitrary_precision" "preserve_order"))) (o #t) (d #t) (k 0)) (d (n "serde_with") (r "^1.9.1") (f (quote ("json"))) (o #t) (d #t) (k 0)) (d (n "sigma-ser") (r "^0.15.0") (d #t) (k 0)) (d (n "sigma-test-util") (r "^0.3.0") (d #t) (k 2)) (d (n "sigma-util") (r "^0.14.0") (d #t) (k 0)) (d (n "thiserror") (r "^1") (d #t) (k 0)))) (h "0c190qwghbk4dapk0g3n944rjr58inykiipycaijxbkqkpm96i18") (f (quote (("json" "serde" "serde_json" "serde_with" "bounded-vec/serde") ("default" "json") ("arbitrary" "proptest" "proptest-derive" "ergotree-ir/arbitrary" "ergo-chain-types/arbitrary" "gf2_192/arbitrary"))))))

